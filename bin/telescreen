#!/usr/bin/python3 -tt
# -*- coding: utf-8 -*-

# Import the GObject-Introspection-compatible Twisted reactor.
from twisted.internet import gireactor

# Register the reactor with GObject for Clutter compatibility.
# Use GObject-Introspection for the Gtk infrastructure bindings.
# We are going to use Clutter and ClutterGst that are normally not exposed.
import gi

# Specify versions of components we are going to use.
gi.require_version('GdkPixbuf', '2.0')
gi.require_version('GtkClutter', '1.0')
gi.require_version('Gtk', '3.0')
gi.require_version('Gdk', '3.0')
gi.require_version('Clutter', '1.0')
gi.require_version('ClutterGst', '3.0')
gi.require_version('Gst', '1.0')
gi.require_version('GObject', '2.0')
gi.require_version('WebKit2', '4.0')


from gi.repository import GtkClutter
from gi.repository import ClutterGst
from gi.repository import GObject
from gi.repository import Gdk
from gi.repository import Gst
from gi.repository import Gtk
from gi.repository import Clutter

from getopt import gnu_getopt
from sys import argv, stderr, exit

r, argv = GtkClutter.init(argv)
argv = Gdk.init(argv)
argv = Gst.init(argv)
r, argv = ClutterGst.init(argv)

gireactor.install(useGtk=True)

# Import all application handles.
from telescreen import Manager, Screen
from telescreen.client import make_client

# Get rest of the Twisted.
from twisted.internet import reactor
from twisted.python import log

# Command line arguments follow the GNU conventions.
from gi.repository.Gtk import Application
from twisted.internet.defer import Deferred


def do_start(connect_to, machine, check_interval):
    # Start Twisted logging to console.
    log.startLogging(stderr)


    # Prepare a 0MQ router instance for communication with the
    # leader that publishes our indoctrination schedule.
    # Prepare the screen that is presented to the user.
    screen = Screen()

    # Set the correct thread pool size for the manager.
    reactor.suggestThreadPoolSize(2)

    # Obtain the unique machine identifier.


    # Prepare the manager that communicates with the leader and
    # controls the screen instance above.
    manager = Manager(screen, machine, check_interval)
    manager.client = make_client(manager, connect_to)
    # Route 0MQ messages to the manager.

    # Schedule a call to the manager right after we finish here.
    reactor.callLater(0, manager.start)

    # Also draw the initial, blank screen as soon as possible.
    reactor.callLater(0, screen.start)

    # Run Gtk / Twisted reactor until the user terminates us.
    reactor.run()


def do_help(*args, **kwargs):
    print('Usage: telescreen [--id=tv1] [--connect=tcp://127.0.0.1:5001]')
    print('Run the telescreen with given configuration.')
    print('')
    print('OPTIONS:')
    print('  --help, -h             Display this help.')
    print('  --version, -V          Display version info.')
    print('')
    print('  --connect, -c url      Connect to specified 0MQ endpoint.')
    print('  --id                   Set machine id')
    print('  --check-interval, -i   Set check interval, default 300.')
    print('')
    print('The 0MQ endpoint must belong to an instance of the "party-daemon"')
    print('application responding to messages addressed to the "leader".')
    print('')
    print('Report bugs at <http://github.com/techlib/telescreen>.')


def do_version(*args, **kwargs):
    print('telescreen (NTK) 1')


def main():
    # Initialize the graphical libraries.

    # Parse command line arguments.
    global argv
    opts, args = gnu_getopt(argv, 'hVi:c:', ['help', 'version', 'id=', 'connect='])

    action = do_start
    connect_to = 'tcp://127.0.0.1:5001'
    machine = None
    with open('/etc/machine-id') as fp:
        machine = fp.read().strip()
    check_interval = 300

    for k, v in opts:
        if k in ('--help', '-h'):
            action = do_help
        elif k in ('--version', '-V'):
            action = do_version
        elif k in ('--connect', '-c'):
            connect_to = v
        elif k in ('--id',):
            machine = v
        elif k in ('--check-interval', '-i'):
            check_interval = int(v)

    # Perform the selected action.
    action(connect_to, machine, check_interval)


if __name__ == '__main__':
    main()

# vim:set sw=4 ts=4 et:
